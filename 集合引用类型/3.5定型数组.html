<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    // 定型数组是类似ArrayBuffer的视图,与其区别是遵循系统原生字节序,有更多API
    // 定型数组出现的目的是为了提高与WebGL原生库交换二进制数据的效率,使用二进制数据

    // 创建定型数组能通过读取已有/自存缓冲内存,<ElementType>.from()/of()也能创建
    const buf=new ArrayBuffer(8);
    const ints=new Int32Array(buf);
    console.log(ints.length)//数组中的每个元素4字节 所以buf能放下两个元素,所以长度为2
    console.log(ints.buffer.byteLength);//缓冲内存有多少字节
    console.log('-----------------------------');

    const ints1=new Int32Array(6);//int32Array(数组长度),直接用自有缓存创建定型数组
    console.log(ints1.length);//6
    console.log(ints1.buffer.byteLength);//6个元素*每个元素4字节=总共用24字节
    console.log('-----------------------------');

    const ints2=new Int32Array([1,3,6,7])//创建定型数组时传参数组
    console.log(ints2.length);//4
    console.log(ints2.buffer.byteLength);//用了16字节
    console.log(ints2[2]);//元素6
    console.log('-----------------------------');

    const float=Float32Array.of(1.35,1.6997,9.99)
    console.log(float.length);//3
    console.log(float.buffer.byteLength);//12
    console.log(float[2]);
    console.log('-----------------------------');

    //夹板数据类型 Uint8ClampedArray() 元素大小溢出会变为最大/最小值 据说最好只做canvas时用它 

    // 定型数组的实例与构造函数都有BYTES_PER_ELEMENT属性,返回该类型数组中每个元素的字节数
    const arr=new Int16Array(3)//每个元素2字节,每个元素16位
    const arr1=new Int32Array(3)//每个元素4字节 每个元素32位
    const arr2=new Float64Array(3)//每个元素8字节
    console.log(arr.BYTES_PER_ELEMENT,arr1.BYTES_PER_ELEMENT,arr2.BYTES_PER_ELEMENT);//2 4 8
    // 没有传值的定型数组,元素值都是0
    console.log(arr[0]);//0
  </script>
</body>
</html>